<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FreeNOS: About</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FreeNOS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">About </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>FreeNOS (Free Niek's Operating System) is an experimental microkernel based operating system for learning purposes written in C++. You may use the code as you wish under the terms of the GPLv3.</p>
<p>Visit the project website at <a href="http://www.FreeNOS.org">http://www.FreeNOS.org</a> for more information.</p>
<h1>Features </h1>
<ul>
<li>Intel x86 (PC) and ARMv6/ARMv7 architectures (Raspberry Pi 1,2,3)</li>
<li>Virtual memory</li>
<li>Simple task scheduling</li>
<li>Inter <a class="el" href="classProcess.html" title="Represents a process which may run on the host. ">Process</a> Communication (IPC)</li>
<li>Symmetric Multi Processing with MPI support (Intel x86 only)</li>
<li>Devices:<ul>
<li>VGA/Keyboard consoles (also supported by Ed's libteken (<a href="http://80386.nl/projects/libteken/">http://80386.nl/projects/libteken/</a>)</li>
<li><a class="el" href="classi8250.html" title="i8250 serial UART. ">i8250</a> serial UART</li>
<li>PCI host controller</li>
<li>CMOS RTC clock</li>
<li>ATA host controller</li>
<li><a class="el" href="namespaceUSB.html" title="USB 2.0 definitions. ">USB</a> controller and (root)hub (Raspberry Pi only)</li>
<li><a class="el" href="classLoopback.html" title="Loopback network device implementation. ">Loopback</a> network and <a class="el" href="classSMSC95xx.html" title="SMSC95xx USB-based Ethernet controller. ">SMSC95xx</a> ethernet (Raspberry Pi only)</li>
</ul>
</li>
<li>Filesystems:<ul>
<li>Virtual file system (VFS)</li>
<li>Temporary file system (TmpFS)</li>
<li>Linnenbank file system (LinnFS)</li>
</ul>
</li>
<li>Networking (IP, <a class="el" href="classUDP.html" title="User Datagram Protocol (UDP) ">UDP</a>, <a class="el" href="classICMP.html" title="Internet Control Message Protocol (ICMP) ">ICMP</a>, for Raspberry pi 1 only)</li>
<li>POSIX, ANSI C libraries</li>
<li>Dynamic and Shared memory</li>
<li>Fully automatic autotester</li>
<li>All sources documented with Doxygen (<a href="http://www.doxygen.org">http://www.doxygen.org</a>)</li>
<li>User and kernel code written from scratch in C++</li>
<li>Very small microkernel (~2K lines of C++ code including a tiny part in assembly)</li>
<li>Builds with recent GCC (<a href="http://gcc.gnu.org">http://gcc.gnu.org</a>), LLVM (<a href="http://www.llvm.org">http://www.llvm.org</a>) and SCons (<a href="http://www.scons.org">http://www.scons.org</a>) versions on POSIX systems</li>
</ul>
<h1>Host Setup </h1>
<p>First install all required build dependencies. FreeNOS needs SCons, an C++ compiler and for Intel targets a tool to generate ISO images. Follow the instructions below to install the build dependencies on your host OS.</p>
<p><em>Ubuntu</em></p>
<p>Update your system repository cache and install the required development tools using: </p><pre class="fragment">$ sudo apt-get update
$ sudo apt-get install build-essential scons genisoimage xorriso qemu-system
</pre><p>If your Ubuntu host is 64-bit, you need to install the GCC multilib package to cross compile for the 32-bit architecture: </p><pre class="fragment">$ sudo apt-get install gcc-multilib g++-multilib
</pre><p>Alternatively, you can install the LLVM/Clang compiler as well: </p><pre class="fragment">$ sudo apt-get install clang
</pre><p><em>FreeBSD</em></p>
<p>Update your system repository cache and install the required development tools using: </p><pre class="fragment">% su -
# pkg update
# pkg install qemu scons cdrkit-genisoimage xorriso gcc
</pre><p>On FreeBSD, make sure that the latest version of the GNU linker (from pkg) is used: </p><pre class="fragment"># mv /usr/bin/ld.bfd /usr/bin/ld.bfd.orig
</pre><h1>Building FreeNOS </h1>
<p>To download and extract the released source code on your host OS, run the following commands. Replace 'x.x.x' with the version of FreeNOS: </p><pre class="fragment">$ wget http://www.FreeNOS.org/pub/FreeNOS/source/FreeNOS-x.x.x.tar.gz
$ tar zxf FreeNOS-x.x.x.tar.gz
</pre><p>To get the latest development source, you can clone the GIT archive: </p><pre class="fragment">$ git clone https://github.com/nieklinnenbank/FreeNOS
</pre><p>To build FreeNOS using default settings (Intel, using GCC with debugging enabled), run: </p><pre class="fragment">$ scons
</pre><p>To build FreeNOS with all full build commands printed on the console, set the VERBOSE build variable to True: </p><pre class="fragment">$ scons VERBOSE=True
</pre><p>To build FreeNOS with compiler optimizations enabled, set DEBUG to False. Note that will make debugging using GDB more difficult: </p><pre class="fragment">$ scons DEBUG=False
</pre><p>Instead of providing build variables on the command line, you can also change the 'build.conf' configuration file for the target. The build configuration file contains build variables, such as compiler flags and parameters for the target. Similary, the 'build.host.conf' file contains build variables for the host OS programs. See the example build.conf and build.host.conf files for more details.</p>
<p>Additionally, any environment variables set in the shell will be automatically converted to identical build variables when running scons.</p>
<p>To build for the Raspberry Pi 2, copy the example build configuration file and run SCons: </p><pre class="fragment">$ cp config/arm/raspberry2/build.conf .
$ scons
</pre><p>To cleanup your build directory, use: </p><pre class="fragment">$ scons -c
</pre><p>Or use the following command to also remove temporary SCons files: </p><pre class="fragment">$ rm -rf build .sconf_temp .sconsign.dblite
</pre><h1>Running FreeNOS </h1>
<p>To run the autotester of FreeNOS on the host OS, run: </p><pre class="fragment">$ scons test
</pre><p>To run the same autotester on FreeNOS under Qemu, run: </p><pre class="fragment">$ scons qemu_test
</pre><p>To start FreeNOS in a Qemu virtual machine with a serial console, use the following command: </p><pre class="fragment">$ scons qemu
</pre><p>To debug FreeNOS using GDB, you need to have build using the DEBUG=False build variable. Ensure that your host OS has GDB available for debugging the target architecture (Intel or ARM). For Ubuntu: </p><pre class="fragment">$ sudo apt-get install gdb-multiarch
</pre><p>Open two terminals. In the first terminal, launch FreeNOS in Qemu with the internal gdbserver enabled: </p><pre class="fragment">$ scons qemu_debug
</pre><p>In the second terminal, start GDB and connect to the Qemu internal gdbserver using: </p><pre class="fragment">$ gdb-multiarch ./build/intel/pc/kernel/intel/pc/kernel
(gdb) target remote localhost:1234
</pre><p>You can now use standard GDB commands to interactively debug the FreeNOS kernel for intel. Similarly, you can also debug a user program (./build/intel/pc/bin/XXX) or the FreeNOS kernel for ARM (./build/arm/raspberry2/kernel/arm/raspberry2/kernel).</p>
<h2>intel/pc </h2>
<p>For Intel targets, you can also launch Qemu using the graphical <a class="el" href="classVGA.html" title="Video Graphics Array (VGA) support. ">VGA</a> console (using SDL): </p><pre class="fragment">$ scons qemu_sdl
</pre><p>To test FreeNOS on real hardware, write the boot ISO to a bootable device, such as an <a class="el" href="namespaceUSB.html" title="USB 2.0 definitions. ">USB</a> disk. Insert the <a class="el" href="namespaceUSB.html" title="USB 2.0 definitions. ">USB</a> disk to your host OS and find the appropriate device name: </p><pre class="fragment">$ fdisk -l
</pre><p>Alternatively, use the dmesg command to find the device name. Write the boot ISO using the following command, where sdX is the name of the <a class="el" href="namespaceUSB.html" title="USB 2.0 definitions. ">USB</a> disk device. Note: make sure to select the correct device to prevent data loss: </p><pre class="fragment">$ sudo dd if=build/intel/pc/boot.iso of=/dev/sdX
$ sudo sync
</pre><p>Insert the <a class="el" href="namespaceUSB.html" title="USB 2.0 definitions. ">USB</a> disk device to the target system and make sure to choose it as boot device when the computer starts (e.g. via BIOS). You should see the FreeNOS <a class="el" href="classVGA.html" title="Video Graphics Array (VGA) support. ">VGA</a> console.</p>
<h2>arm/raspberry </h2>
<p>To build FreeNOS for running on the Raspberry Pi 1, use the provided build.conf file and rebuild the system: </p><pre class="fragment">$ cp config/arm/raspberry/build.conf .
$ scons
</pre><p>To test FreeNOS for the raspberry pi 1 under Qemu, rebuild the system with the QEMU_BUILD build variable set to True: </p><pre class="fragment">$ scons QEMU_BUILD=True
$ scons qemu
</pre><p>To test on a real Raspberry Pi using SD card, download the latest Raspbian 'Lite' image from <a href="https://www.raspberrypi.org/downloads/raspbian/">https://www.raspberrypi.org/downloads/raspbian/</a> and unzip it. Insert the SD card to your reader/writer slot on your host OS and find the appropriate device name using: </p><pre class="fragment">$ fdisk -l
</pre><p>Alternatively, use the dmesg command to find the device name. Write the Raspbian image to the SD card using the following command, where sdX is the name of the SD card device. Note: make sure to select the correct device to prevent data loss: </p><pre class="fragment">$ sudo dd if=/path/to/raspbian/image.img of=/dev/sdX
$ sudo sync
</pre><p>Re-insert the SD-card to auto mount it on your host OS. Copy the FreeNOS raspberry pi kernel executable to the '/boot' partition on the Raspbian image using (on Ubuntu): </p><pre class="fragment">$ sudo cp build/arm/raspberry/kernel.img /media/boot/kernel.img
$ sudo sync
$ sudo umount /media/boot
</pre><p>You will need a USB-to-TTL-serial cable to connect to the Raspberry Pi UART. Any USB-to-TTL-serial cable will work, for example the Adafruit USB-to-TTL-serial cable: </p><pre class="fragment">https://www.adafruit.com/product/954
</pre><p>Connect your USB-to-serial cable to the Raspberry Pi using the GPIO pins: </p><pre class="fragment">[ ] [ ]
[ ] [X]  Pin 4  (V5)     &lt;---  Red (only needed if powered via USB)
[ ] [X]  Pin 6  (Ground) &lt;---  Black
[ ] [X]  Pin 8  (RX)     &lt;---  White
[ ] [X]  Pin 10 (TX)     &lt;---  Green
[ ] [ ]
[ ] [ ]
[ ] [ ]
[ ] [ ]
[ ] [ ]
</pre><p>Also see the following tutorial by Adafruit on connecting the serial cable to the Raspberry Pi: </p><pre class="fragment">https://learn.adafruit.com/adafruits-raspberry-pi-lesson-5-using-a-console-cable/connect-the-lead
</pre><p>Connect your Raspberry Pi to the host to power it via <a class="el" href="namespaceUSB.html" title="USB 2.0 definitions. ">USB</a> or use an external power adapter. On the host OS, launch a serial console client program such as minicom and connect it to the <a class="el" href="namespaceUSB.html" title="USB 2.0 definitions. ">USB</a> serial device (baudrate 115200): </p><pre class="fragment">$ minicom -D /dev/ttyUSB0
</pre><p>You should now see the FreeNOS console output.</p>
<h2>arm/raspberry2 </h2>
<p>Follow the same instructions as for the Raspberry Pi 1 above, but use the Raspberry Pi 2 configuration file instead to build FreeNOS: </p><pre class="fragment">$ cp config/arm/raspberry2/build.conf .
$ scons
</pre><p>When copying the kernel executable to the SD card '/boot' partition, use the 'kernel7.img' filename to make sure the Raspberry Pi bootloader correctly starts the kernel (ARMv7): </p><pre class="fragment">$ cp build/arm/raspberry/kernel.img /media/boot/kernel7.img
</pre><p>Additionally, for raspberry pi 2 and newer, add the following to the /boot/config.txt file to ensure the first UART is available on GPIO pins 8 and 10: </p><pre class="fragment">dtoverlay=pi3-miniuart-bt
enable_uart=1
</pre><h1>Using FreeNOS </h1>
<p>When FreeNOS starts the system will print bootup output and present the system login prompt. Currently the login will accept any username value and does not ask for a password. The FreeNOS interactive console prompt looks like the following: </p><pre class="fragment">(localhost) / #
</pre><p>FreeNOS has a UNIX-like interface and you may enter any of the commands available in the /bin directory: </p><pre class="fragment">(localhost) / # ls bin
</pre><p>For example, the 'ps' command prints a list of all processes running in the system: </p><pre class="fragment">(localhost) / # ps
</pre><p>You can also run the fully automatic autotester inside Qemu or on real hardware using the following command: </p><pre class="fragment">(localhost) / # /test/run
</pre><p>To view some information about the FreeNOS version and hardware settings you can use the 'sysinfo' command: </p><pre class="fragment">(localhost) / # sysinfo
</pre><p>The '/' in the prompt indicates the current active directory. Change it with the 'cd' built-in shell command: </p><pre class="fragment">(localhost) / # cd /tmp
(localhost) /tmp #
</pre><p>The FreeNOS shell has several built-in commands, use the 'help' command to view all the built-in shell commands: </p><pre class="fragment">(localhost) / # help
</pre><p>Example application program for calculating prime numbers is the /bin/prime command. To let it compute all prime numbers up to 1024 and output the prime number results use: </p><pre class="fragment">(localhost) / # prime --stdout 1024
</pre><p>For Intel, the prime command also has a MPI variant called 'mpiprime' which can compute the prime numbers in parallel using multiple cores. To run it and let the shell measure the time taken use: </p><pre class="fragment">(localhost) / # time mpiprime 2000000
</pre><p>You can compare the time result versus the time take of the single core program where it computes the same number of primes: </p><pre class="fragment">(localhost) / # time prime 2000000
</pre><h1>Jenkins Continuous Integration </h1>
<h2>Master Setup </h2>
<p>Install Jenkins on your host OS using your favorite package manager or from the official website (<a href="https://jenkins.io/">https://jenkins.io/</a>). Follow the installation wizard instructions and after installation go to the Jenkins web interface at: <a href="http://localhost:8080">http://localhost:8080</a></p>
<p>After installation, navigate to: Manage Jenkins &gt; Manage Plugins Make sure the following plugins are installed. Choose the plugins from the 'Available' tab to find the plugins which are not yet installed:</p>
<ul>
<li>Matrix Project Plugin (<a href="https://wiki.jenkins-ci.org/display/JENKINS/Matrix+Project+Plugin">https://wiki.jenkins-ci.org/display/JENKINS/Matrix+Project+Plugin</a>)</li>
<li>Matrix Combinations Plugin (<a href="https://wiki.jenkins-ci.org/display/JENKINS/matrix+combinations+plugin">https://wiki.jenkins-ci.org/display/JENKINS/matrix+combinations+plugin</a>)</li>
<li>Node and Label Parameter Plugin (<a href="https://wiki.jenkins-ci.org/display/JENKINS/NodeLabel+Parameter+Plugin">https://wiki.jenkins-ci.org/display/JENKINS/NodeLabel+Parameter+Plugin</a>)</li>
<li>Libvirt Slaves Plugin (<a href="https://wiki.jenkins.io/display/JENKINS/Libvirt+Slaves+Plugin">https://wiki.jenkins.io/display/JENKINS/Libvirt+Slaves+Plugin</a>)</li>
<li>SSH Plugin (<a href="https://wiki.jenkins-ci.org/display/JENKINS/SSH+plugin">https://wiki.jenkins-ci.org/display/JENKINS/SSH+plugin</a>)</li>
<li>Workspace Cleanup Plugin (<a href="https://wiki.jenkins-ci.org/display/JENKINS/Workspace+Cleanup+Plugin">https://wiki.jenkins-ci.org/display/JENKINS/Workspace+Cleanup+Plugin</a>)</li>
</ul>
<p>After finishing Jenkins configuration, install KVM and Libvirt on your host OS. For Ubuntu use: </p><pre class="fragment">$ sudo apt-get install qemu-kvm libvirt-bin virtinst
</pre><p>Connect Jenkins to libvirt via SSH, navigate to: Manage Jenkins &gt; Configure System Choose 'Add a new cloud' and select 'Hypervisor Type': QEMU, 'Hypervisor Host': localhost and choose your desired SSH username.</p>
<p>Press 'Advanced' to choose authentication parameters and press 'Test Connection' to verify Jenkins can access libvirt via SSH. For Ubuntu, you need to ensure the SSH user is in the 'kvm' and 'libvirtd' groups: </p><pre class="fragment">$ sudo usermod -a -G kvm,libvirtd jenkins
</pre><p>Jenkins need to find the KVM guests by their hostname. You can either manually configure the DNS hostname to IP translation in the /etc/hosts file or automatically using the internal libvirt DNSMasq server.</p>
<p>To setup automatic DNS translation in KVM, first edit the 'default' libvirt network interface to add the '.kvm' local-only domain: </p><pre class="fragment">$ virsh net-edit default
</pre><p>Add the following line inside the &lt;network&gt;....&lt;/network&gt; tag: </p><pre class="fragment">&lt;domain name='kvm' localOnly='yes'/&gt;
</pre><p>To use the libvirt internal DNSMasq server on your host, you may change the /etc/resolv.conf file to add the following: </p><pre class="fragment">nameserver 192.168.122.1
</pre><p>If your host OS uses NetworkManager for networking, add the following files: </p><pre class="fragment">$ sudo -s
# cat &gt; /etc/NetworkManager/conf.d/localdns.conf
[main]
dns=dnsmasq

# cat &gt; /etc/NetworkManager/dnsmasq.d/libvirt_dnsmasq.conf
server=/kvm/192.168.122.1
</pre><p>Ensure that all KVM guests have their hostname set in the .kvm domain (e.g. someguest.kvm). Restart libvirt and optionally NetworkManager to apply the changes: </p><pre class="fragment">$ sudo /etc/init.d/libvirt-bin restart
$ sudo /etc/init.d/NetworkManager restart
</pre><p>You should now be able to resolve the hostnames of your guests in the .kvm domain after they are started, for example: </p><pre class="fragment">$ virsh start ubuntu-1804
$ host ubuntu-1804.kvm
</pre><p>Also visit the following page for more details on this automatic DNS setup for KVM: <a href="https://liquidat.wordpress.com/2017/03/03/howto-automated-dns-resolution-for-kvmlibvirt-guests-with-a-local-domain/">https://liquidat.wordpress.com/2017/03/03/howto-automated-dns-resolution-for-kvmlibvirt-guests-with-a-local-domain/</a></p>
<h2>FreeBSD 12.0 Slave </h2>
<p>Run the example installation script in ./support/jenkins/freebsd-12.sh from the FreeNOS sources to setup the KVM guest with FreeBSD 12.0. Also see the comments in the installation script for more info: </p><pre class="fragment">jenkins@host$ cd support/jenkins
jenkins@host$ ./freebsd-12.sh
</pre><p>To configure the FreeBSD 12.0 slave in Jenkins for building FreeNOS, you first need to make sure the Jenkins user can login to the slave using SSH. Optionally, you can configure this with public key authentication: </p><pre class="fragment">jenkins@host$ virsh start freebsd-12
jenkins@host$ ssh-keygen
jenkins@host$ ssh-copy-id jenkins@freebsd-12.kvm
</pre><p>Test if the Jenkins user can login to the FreeBSD KVM guest with SSH (via password or key): </p><pre class="fragment">jenkins@host$ ssh jenkins@freebsd-12.kvm
</pre><p>Copy the example node configuration XML file to the Jenkins installation directory: </p><pre class="fragment">jenkins@host$ mkdir /var/lib/jenkins/nodes/freebsd-12-test
jenkins@host$ cp freebsd-12.node.xml /var/lib/jenkins/nodes/freebsd-12-test/config.xml
</pre><p>Also copy the job configuration XML file to the Jenkins installation directory: </p><pre class="fragment">jenkins@host$ mkdir /var/lib/jenkins/jobs/FreeNOS-freebsd12-test
jenkins@host$ cp freebsd-12.job.xml /var/lib/jenkins/jobs/FreeNOS-freebsd12-test/config.xml
</pre><p>Restart the Jenkins server to use the new configuration files: </p><pre class="fragment">$ sudo /etc/init.d/jenkins restart
</pre><p>Jenkins still needs authentication credentials to connect to the slave. Navigate to: </p><pre class="fragment">Manage Jenkins &gt; Manage Nodes &gt; freebsd-12 &gt; Configure
</pre><p>In the sub-menu 'Secondary launch method', under 'Launch agents via SSH', select existing SSH credentials to let jenkins use it to login to the slave node or add a new credentials with the 'Add' button. If you generated an SSH key for the jenkins user on the host OS, insert the SSH private key or provide username/password.</p>
<p>Press the 'Save' button to finish and use 'Launch Agent' to test the connection.</p>
<p>You can now press the 'Schedule a Build' button on the 'FreeNOS-freebsd12' build job to test.</p>
<h2>Ubuntu 18.04 Slave </h2>
<p>Follow the same instructions as the FreeBSD 12.0 Slave above and just replace the slave name with 'ubuntu-1804'.</p>
<h1>Authors </h1>
<p>The FreeNOS code has been written from scratch by Niek Linnenbank. People who contributed to FreeNOS are:</p>
<ul>
<li>Dan Rulos (AmayaOS)</li>
<li>Coen Bijlsma (libparse, srv/time)</li>
<li>Ed Schouten (libteken)</li>
<li>Alexander Schrijver (OpenBSD patches) </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
